diff --git a/src/animation/execution/scene-renderer.ts b/src/animation/execution/scene-renderer.ts
index d9adea6..a047c05 100644
--- a/src/animation/execution/scene-renderer.ts
+++ b/src/animation/execution/scene-renderer.ts
@@ -1,11 +1,12 @@
 // src/animation/execution/scene-renderer.ts
 import type { NodeCanvasContext, Point2D, Transform } from '@/shared/types/core';
-import type { AnimationScene, SceneObject, ObjectState, TriangleProperties, CircleProperties, RectangleProperties, TextProperties } from '@/shared/types/scene';
+import type { AnimationScene, SceneObject, ObjectState, TriangleProperties, CircleProperties, RectangleProperties, ImageProperties, TextProperties } from '@/shared/types/scene';
 import { Timeline } from '../scene/timeline';
 import { drawTriangle, type TriangleStyle } from '../geometry/triangle';
 import { drawCircle, type CircleStyle } from '../geometry/circle';
 import { drawRectangle, type RectangleStyle } from '../geometry/rectangle';
 import { drawText, type Typography } from '../geometry/text';
+import { loadImage } from 'canvas';
 
 function applyTranslation(
   ctx: NodeCanvasContext | CanvasRenderingContext2D,
@@ -40,12 +41,13 @@ function applyTransform(
 function saveAndTransform(
   ctx: NodeCanvasContext | CanvasRenderingContext2D,
   transform: Transform,
-  drawCallback: () => void
-): void {
+  drawCallback: () => void | Promise<void>
+): void | Promise<void> {
   ctx.save();
   applyTransform(ctx, transform);
-  drawCallback();
+  const result = drawCallback();
   ctx.restore();
+  return result;
 }
 
 export interface SceneRenderConfig {
@@ -65,9 +67,10 @@ export class SceneRenderer {
     this.timeline = new Timeline(scene);
   }
 
-  renderFrame(ctx: NodeCanvasContext, time: number): void {
+  async renderFrame(ctx: NodeCanvasContext, time: number): Promise<void> {
     // Clear canvas with background
     const bgColor = this.scene.background?.color ?? this.config.backgroundColor;
+    console.log('[DEBUG] SceneRenderer: Setting background color:', bgColor, 'for canvas size:', this.config.width, 'x', this.config.height);
     ctx.fillStyle = bgColor;
     ctx.fillRect(0, 0, this.config.width, this.config.height);
 
@@ -75,15 +78,20 @@ export class SceneRenderer {
     const sceneState = this.timeline.getSceneState(time);
 
     // Render each object
+    console.log('[DEBUG] SceneRenderer: Rendering', this.scene.objects.length, 'objects');
     for (const object of this.scene.objects) {
       const state = sceneState.get(object.id);
-      if (!state) continue;
+      if (!state) {
+        console.log('[DEBUG] SceneRenderer: No state for object', object.id);
+        continue;
+      }
 
-      this.renderObject(ctx, object, state);
+      console.log('[DEBUG] SceneRenderer: Rendering object', object.id, 'of type', object.type, 'at position', state.position);
+      await this.renderObject(ctx, object, state);
     }
   }
 
-  private renderObject(ctx: NodeCanvasContext, object: SceneObject, state: ObjectState): void {
+  private async renderObject(ctx: NodeCanvasContext, object: SceneObject, state: ObjectState): Promise<void> {
     const transform = {
       translate: state.position,
       rotate: state.rotation,
@@ -94,7 +102,7 @@ export class SceneRenderer {
     const originalAlpha = ctx.globalAlpha;
     ctx.globalAlpha = originalAlpha * state.opacity;
 
-    saveAndTransform(ctx, transform, () => {
+    await saveAndTransform(ctx, transform, async () => {
       switch (object.type) {
         case 'triangle':
           this.renderTriangle(ctx, object.properties as TriangleProperties, state);
@@ -105,6 +113,9 @@ export class SceneRenderer {
         case 'rectangle':
           this.renderRectangle(ctx, object.properties as RectangleProperties, state);
           break;
+        case 'image':
+          await this.renderImage(ctx, object.properties as ImageProperties, state);
+          break;
         case 'text':
           this.renderText(ctx, object, state);
           break;
@@ -150,6 +161,77 @@ export class SceneRenderer {
     drawRectangle(ctx, { x: -props.width / 2, y: -props.height / 2 }, props.width, props.height, style);
   }
 
+  private async renderImage(ctx: NodeCanvasContext, props: ImageProperties, _state: ObjectState): Promise<void> {
+    // Skip rendering if no image URL
+    if (!props.imageUrl) {
+      console.log('[DEBUG] renderImage: No imageUrl, skipping');
+      return;
+    }
+
+    // Calculate final dimensions based on crop and display settings
+    // cropWidth/Height = 0 means "use original size"
+    // displayWidth/Height = 0 means "use crop size"
+    const cropWidth = props.cropWidth !== 0 ? props.cropWidth : (props.originalWidth ?? 100);
+    const cropHeight = props.cropHeight !== 0 ? props.cropHeight : (props.originalHeight ?? 100);
+    const finalWidth = props.displayWidth !== 0 ? props.displayWidth : cropWidth;
+    const finalHeight = props.displayHeight !== 0 ? props.displayHeight : cropHeight;
+    
+    // Ensure we have valid dimensions
+    const width = finalWidth ?? 100;
+    const height = finalHeight ?? 100;
+    
+    console.log('[DEBUG] renderImage: Rendering image with dimensions:', { width, height, props });
+    
+    // Try to load and render the actual image
+    try {
+      console.log('[DEBUG] renderImage: Starting to load image from:', props.imageUrl);
+      
+      // Load the image and wait for it to complete
+      const img = await loadImage(props.imageUrl);
+      console.log('[DEBUG] renderImage: Image loaded successfully, dimensions:', img.width, 'x', img.height);
+      
+      // Calculate crop and display parameters
+      const srcX = props.cropX ?? 0;
+      const srcY = props.cropY ?? 0;
+      const srcWidth = props.cropWidth ?? img.width;
+      const srcHeight = props.cropHeight ?? img.height;
+      
+      // Draw the image centered at origin
+      ctx.drawImage(
+        img,
+        srcX, srcY, srcWidth, srcHeight,  // Source rectangle
+        -width / 2, -height / 2, width, height  // Destination rectangle
+      );
+      
+      console.log('[DEBUG] renderImage: Image drawing complete');
+      
+    } catch (error) {
+      console.error('[DEBUG] renderImage: Failed to load image:', error);
+      // Fallback to placeholder if image loading fails
+      this.drawImagePlaceholder(ctx, width, height);
+    }
+  }
+  
+  private drawImagePlaceholder(ctx: NodeCanvasContext, width: number, height: number): void {
+    console.log('[DEBUG] drawImagePlaceholder: Drawing placeholder rectangle at', -width / 2, -height / 2, 'with size', width, height);
+    
+    // Draw placeholder rectangle
+    ctx.fillStyle = '#cccccc';
+    ctx.strokeStyle = '#999999';
+    ctx.lineWidth = 2;
+    ctx.fillRect(-width / 2, -height / 2, width, height);
+    ctx.strokeRect(-width / 2, -height / 2, width, height);
+    
+    // Add text to indicate it's a placeholder
+    ctx.fillStyle = '#666666';
+    ctx.font = '16px Arial';
+    ctx.textAlign = 'center';
+    ctx.textBaseline = 'middle';
+    ctx.fillText('IMAGE PLACEHOLDER', 0, 0);
+    
+    console.log('[DEBUG] drawImagePlaceholder: Drawing complete');
+  }
+
   private renderText(ctx: NodeCanvasContext, object: SceneObject, state: ObjectState): void {
     const props = object.properties as TextProperties;
     const typography = object.typography; // Applied by Typography node
diff --git a/src/components/workspace/media-editor-tab.tsx b/src/components/workspace/media-editor-tab.tsx
index ad518ae..6f5bb1f 100644
--- a/src/components/workspace/media-editor-tab.tsx
+++ b/src/components/workspace/media-editor-tab.tsx
@@ -749,7 +749,9 @@ export function MediaEditorTab({ nodeId }: { nodeId: string }) {
             onChange={handleUpdateAssignment}
           />
         ) : (
-          <MediaDefaultProperties nodeId={nodeId} />
+          <div className="text-sm text-[var(--text-tertiary)]">
+            Select an object on the left to edit its specific properties, or use the center panel to edit global defaults.
+          </div>
         )}
       </div>
     </div>
diff --git a/src/lib/flow/flow-tracking.ts b/src/lib/flow/flow-tracking.ts
index 4f00978..5ee6a2a 100644
--- a/src/lib/flow/flow-tracking.ts
+++ b/src/lib/flow/flow-tracking.ts
@@ -132,6 +132,7 @@ export class FlowTracker {
     // Get all node types from registry
     const geometryNodeTypes = getNodesByCategory('geometry').map(def => def.type);
     const textNodeTypes = getNodesByCategory('text').map(def => def.type);
+    const imageNodeTypes = getNodesByCategory('image').map(def => def.type);
     const dataNodeTypes = getNodesByCategory('data').map(def => def.type);
     const duplicateNodeTypes = ['duplicate']; // Can be expanded for other multiplier nodes
 
@@ -160,8 +161,8 @@ export class FlowTracker {
         return [];
       }
 
-      // If this is a geometry node OR text node, it creates new visual objects
-      if (geometryNodeTypes.includes(currentNode.type!) || textNodeTypes.includes(currentNode.type!)) {
+      // If this is a geometry node OR text node OR image node, it creates new visual objects
+      if (geometryNodeTypes.includes(currentNode.type!) || textNodeTypes.includes(currentNode.type!) || imageNodeTypes.includes(currentNode.type!)) {
         const newObject: ObjectDescriptor = {
           id: currentNode.data.identifier.id,
           nodeId: currentNode.data.identifier.id,
@@ -250,8 +251,8 @@ export class FlowTracker {
         }
       }
 
-      // If no input ports have objects and this is a geometry node, it's a source
-      if (objectsByPort.size === 0 && geometryNodeTypes.includes(currentNode.type!)) {
+      // If no input ports have objects and this is a geometry node or image node, it's a source
+      if (objectsByPort.size === 0 && (geometryNodeTypes.includes(currentNode.type!) || imageNodeTypes.includes(currentNode.type!))) {
         const emptyMap = new Map([['input', []]]);
         return traceObjects(currentNodeId, emptyMap);
       }
diff --git a/src/server/animation-processing/executors/animation-executor.ts b/src/server/animation-processing/executors/animation-executor.ts
index ba3b673..ec3d3f3 100644
--- a/src/server/animation-processing/executors/animation-executor.ts
+++ b/src/server/animation-processing/executors/animation-executor.ts
@@ -184,7 +184,12 @@ export class AnimationNodeExecutor extends BaseExecutor {
       typeof obj === 'object' &&
       obj !== null &&
       'type' in obj &&
-      (obj as { type: string }).type === 'image'
+      (obj as { type: string }).type === 'image' &&
+      'initialPosition' in obj &&
+      'initialRotation' in obj &&
+      'initialScale' in obj &&
+      'initialOpacity' in obj &&
+      'properties' in obj
     );
   }
 
@@ -205,6 +210,17 @@ export class AnimationNodeExecutor extends BaseExecutor {
     _context: ExecutionContext
   ): Promise<SceneObject> {
     const objectId = obj.id;
+    
+    // Debug logging to check object structure
+    logger.debug(`Processing image object ${objectId}:`, {
+      hasInitialPosition: !!obj.initialPosition,
+      hasInitialRotation: !!obj.initialRotation,
+      hasInitialScale: !!obj.initialScale,
+      hasInitialOpacity: !!obj.initialOpacity,
+      initialPosition: obj.initialPosition,
+      type: obj.type
+    });
+    
     const reader = readVarForObject(objectId);
     
     // Build object-specific overrides
@@ -261,11 +277,12 @@ export class AnimationNodeExecutor extends BaseExecutor {
           .eq('id', finalOverrides.imageAssetId)
           .single();
 
-        const { data: asset, error } = result;
+        const { data: asset, error } = result as { data: unknown; error: unknown };
         
         if (!error && asset && typeof asset === 'object' && asset !== null) {
-          const bucketName = (asset as { bucket_name?: string }).bucket_name;
-          const storagePath = (asset as { storage_path?: string }).storage_path;
+          const assetRecord = asset as Record<string, unknown>;
+          const bucketName = assetRecord.bucket_name as string | undefined;
+          const storagePath = assetRecord.storage_path as string | undefined;
           
           if (bucketName && storagePath) {
             // Get signed URL
@@ -296,6 +313,11 @@ export class AnimationNodeExecutor extends BaseExecutor {
     // Apply media processing to the image object
     const processed = {
       ...obj,
+      // Ensure timeline properties are preserved
+      initialPosition: obj.initialPosition ?? { x: 0, y: 0 },
+      initialRotation: obj.initialRotation ?? 0,
+      initialScale: obj.initialScale ?? { x: 1, y: 1 },
+      initialOpacity: obj.initialOpacity ?? 1,
       properties: {
         ...obj.properties,
         // Asset properties
@@ -316,6 +338,16 @@ export class AnimationNodeExecutor extends BaseExecutor {
       }
     };
 
+    // Debug logging to verify processed object structure
+    logger.debug(`Processed image object ${objectId}:`, {
+      hasInitialPosition: !!processed.initialPosition,
+      hasInitialRotation: !!processed.initialRotation,
+      hasInitialScale: !!processed.initialScale,
+      hasInitialOpacity: !!processed.initialOpacity,
+      initialPosition: processed.initialPosition,
+      type: processed.type
+    });
+
     return processed;
   }
 
diff --git a/src/server/animation-processing/executors/image-executor.ts b/src/server/animation-processing/executors/image-executor.ts
index 285dfd3..4111378 100644
--- a/src/server/animation-processing/executors/image-executor.ts
+++ b/src/server/animation-processing/executors/image-executor.ts
@@ -14,14 +14,20 @@ export class ImageExecutor extends BaseExecutor {
     context: ExecutionContext,
     _edges: ReactFlowEdge[]
   ): Promise<void> {
-    // Create basic image placeholder object
+    // Create proper SceneObject with timeline-compatible properties
     const imageObject = {
       type: 'image' as const,
       id: `image_${node.data.identifier.id}`,
-      // Basic properties only - no asset loading
+      // Timeline-required properties
+      initialPosition: { x: 0, y: 0 }, // Default origin - Canvas will provide positioning
+      initialRotation: 0,
+      initialScale: { x: 1, y: 1 },
+      initialOpacity: 1,
+      // Basic properties - no asset loading (that's handled by media node)
       placeholder: true,
       nodeId: node.data.identifier.id,
-      displayName: node.data.identifier.displayName
+      displayName: node.data.identifier.displayName,
+      properties: {}
     };
 
     setNodeOutput(
diff --git a/src/server/rendering/image/image-renderer.ts b/src/server/rendering/image/image-renderer.ts
index 5b36f75..799c927 100644
--- a/src/server/rendering/image/image-renderer.ts
+++ b/src/server/rendering/image/image-renderer.ts
@@ -37,7 +37,7 @@ export class ImageRenderer {
     };
 
     const sceneRenderer = new SceneRenderer(scene, renderConfig);
-    sceneRenderer.renderFrame(ctx as never, cfg.time ?? 0);
+    await sceneRenderer.renderFrame(ctx as never, cfg.time ?? 0);
 
     const prepared = await this.storageProvider.prepareTarget(cfg.format);
 
diff --git a/src/shared/properties/resolver.ts b/src/shared/properties/resolver.ts
index c021cc3..115f4cc 100644
--- a/src/shared/properties/resolver.ts
+++ b/src/shared/properties/resolver.ts
@@ -1,6 +1,6 @@
 // src/shared/properties/resolver.ts
 
-import type { GeometryProperties, SceneObject, TriangleProperties, CircleProperties, RectangleProperties, TextProperties } from '@/shared/types/scene';
+import type { GeometryProperties, SceneObject, TriangleProperties, CircleProperties, RectangleProperties, ImageProperties, TextProperties } from '@/shared/types/scene';
 import type { PropertySourceMap } from './precedence';
 import type { ObjectAssignments } from './assignments';
 
@@ -133,6 +133,14 @@ export function resolveInitialObject(
       } as TextProperties; // Remove color extensions
       break;
     }
+    case 'image': {
+      const base = original.properties as ImageProperties;
+      // Image objects don't use Canvas color properties - they're rendered as-is
+      properties = {
+        ...base,
+      } as ImageProperties;
+      break;
+    }
     default: {
       // Type assertion to handle the never case
       const type = original.type as string;
diff --git a/src/shared/types/definitions.ts b/src/shared/types/definitions.ts
index ffb80dd..1f7816b 100644
--- a/src/shared/types/definitions.ts
+++ b/src/shared/types/definitions.ts
@@ -1030,7 +1030,7 @@ export const NODE_DEFINITIONS = {
           key: 'cropWidth', 
           type: 'number', 
           label: 'Crop Width', 
-          min: 1, 
+          min: 0, 
           defaultValue: 0,
           description: 'Crop width (0 = use original)'
         },
@@ -1038,7 +1038,7 @@ export const NODE_DEFINITIONS = {
           key: 'cropHeight', 
           type: 'number', 
           label: 'Crop Height', 
-          min: 1, 
+          min: 0, 
           defaultValue: 0,
           description: 'Crop height (0 = use original)'
         },
@@ -1048,7 +1048,7 @@ export const NODE_DEFINITIONS = {
           key: 'displayWidth', 
           type: 'number', 
           label: 'Display Width', 
-          min: 1, 
+          min: 0, 
           defaultValue: 0,
           description: 'Final display width (0 = use crop size)'
         },
@@ -1056,7 +1056,7 @@ export const NODE_DEFINITIONS = {
           key: 'displayHeight', 
           type: 'number', 
           label: 'Display Height', 
-          min: 1, 
+          min: 0, 
           defaultValue: 0,
           description: 'Final display height (0 = use crop size)'
         }
diff --git a/src/shared/types/scene.ts b/src/shared/types/scene.ts
index a2ee867..f205567 100644
--- a/src/shared/types/scene.ts
+++ b/src/shared/types/scene.ts
@@ -14,7 +14,7 @@ export interface AnimationScene {
 
 export interface SceneObject {
   id: string;
-  type: 'triangle' | 'circle' | 'rectangle' | 'text';
+  type: 'triangle' | 'circle' | 'rectangle' | 'text' | 'image';
   properties: GeometryProperties;
   initialPosition: Point2D;
   initialRotation?: number;
@@ -48,12 +48,25 @@ export interface RectangleProperties {
   height: number;
 }
 
+export interface ImageProperties {
+  imageUrl?: string;
+  originalWidth?: number;
+  originalHeight?: number;
+  assetId?: string;
+  cropX?: number;
+  cropY?: number;
+  cropWidth?: number;
+  cropHeight?: number;
+  displayWidth?: number;
+  displayHeight?: number;
+}
+
 export interface TextProperties {
   content: string;
   fontSize: number;
 }
 
-export type GeometryProperties = TriangleProperties | CircleProperties | RectangleProperties | TextProperties;
+export type GeometryProperties = TriangleProperties | CircleProperties | RectangleProperties | ImageProperties | TextProperties;
 
 // Object state at any point in time
 export interface ObjectState {

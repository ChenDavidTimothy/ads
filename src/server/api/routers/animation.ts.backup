// src/server/api/routers/animation.ts - GUARANTEED FEATURE PRESERVATION
// REPLACE ENTIRE CONTENT OF EXISTING animation.ts FILE
import { z } from "zod";
import { createTRPCRouter, protectedProcedure, publicProcedure } from "@/server/api/trpc";
import { getNodeDefinition } from "@/shared/registry/registry-utils";
import { DEFAULT_SCENE_CONFIG } from "@/server/rendering/renderer";
import { createServiceClient } from "@/utils/supabase/service";
import { generationService } from "../services/generation-service";

// ==================== PRESERVED: EXACT SCHEMAS ====================

const reactFlowNodeSchema = z.object({
  id: z.string(),
  type: z.string().optional(),
  position: z.object({ x: z.number(), y: z.number() }),
  data: z.unknown(),
});

const reactFlowEdgeSchema = z.object({
  id: z.string(),
  source: z.string(),
  target: z.string(),
  sourceHandle: z.string().nullable().optional(),
  targetHandle: z.string().nullable().optional(),
});

const sceneConfigSchema = z.object({
  width: z.coerce.number().max(1920).optional(),
  height: z.coerce.number().max(1080).optional(),
  fps: z.coerce.number().max(60).optional(),
  backgroundColor: z.string().optional(),
  videoPreset: z.string().optional(),
  videoCrf: z.coerce.number().min(0).max(51).optional(),
});

const generateSceneInputSchema = z.object({
  nodes: z.array(reactFlowNodeSchema),
  edges: z.array(reactFlowEdgeSchema),
  config: sceneConfigSchema.optional(),
});

const generateSingleSceneInputSchema = z.object({
  nodes: z.array(reactFlowNodeSchema),
  edges: z.array(reactFlowEdgeSchema), 
  targetSceneNodeId: z.string(),
});

const generateSingleFrameInputSchema = z.object({
  nodes: z.array(reactFlowNodeSchema),
  edges: z.array(reactFlowEdgeSchema),
  targetFrameNodeId: z.string(),
});

const validateSceneInputSchema = z.object({
  nodes: z.array(reactFlowNodeSchema),
  edges: z.array(reactFlowEdgeSchema),
});

// PRESERVED: Debug execution schema
const debugExecutionInputSchema = z.object({
  nodes: z.array(reactFlowNodeSchema),
  edges: z.array(reactFlowEdgeSchema),
  targetNodeId: z.string(),
});

// ==================== ROUTER WITH GUARANTEED FEATURE PRESERVATION ====================

export const animationRouter = createTRPCRouter({
  
  // ==================== PRESERVED: BULK GENERATION WITH ALL FEATURES ====================
  
  generateScene: protectedProcedure
    .input(generateSceneInputSchema)
    .mutation(async ({ input, ctx }) => {
      // PRESERVED: Uses shared service that contains ALL original validation and logic
      return await generationService.generateBulkScenes(
        input.nodes, 
        input.edges, 
        ctx, 
        input.config
      );
    }),

  generateImage: protectedProcedure
    .input(generateSceneInputSchema)
    .mutation(async ({ input, ctx }) => {
      // PRESERVED: Specialized bulk image generation with ALL original features
      try {
        const { backendNodes, backendEdges } = generationService.preprocessInput(input.nodes, input.edges);
        
        // PRESERVED: Complete validation pipeline
        const validation = await generationService.validateComplete(backendNodes, backendEdges, input.nodes, input.edges);
        if (!validation.success) {
          return { success: false, errors: validation.errors, canRetry: true };
        }

        // PRESERVED: Job limit checking
        await generationService.checkJobLimits(ctx);

        // PRESERVED: Engine execution without scene requirement for images
        const { ExecutionEngine } = await import('@/server/animation-processing/execution-engine');
        const engine = new ExecutionEngine();
        engine.runUniversalValidation(backendNodes as any, backendEdges);

        const executionContext = await engine.executeFlow(
          backendNodes as any,
          backendEdges,
          { requireScene: false }
        );

        // PRESERVED: Frame node validation and processing
        const frameNodes = backendNodes.filter((node) => node.type === 'frame') as any[];
        if (frameNodes.length === 0) {
          return {
            success: false,
            errors: [{ type: 'error' as const, code: 'ERR_FRAME_REQUIRED', message: 'Frame node is required', suggestions: ['Add a Frame node from the Output section'] }],
            canRetry: true
          };
        }

        // PRESERVED: Scene partitioning for frames
        const { partitionObjectsByScenes, buildAnimationSceneFromPartition } = await import('@/server/animation-processing/scene/scene-partitioner');
        const scenePartitions = partitionObjectsByScenes(executionContext, frameNodes, backendEdges);
        if (scenePartitions.length === 0) {
          return {
            success: false,
            errors: [{ type: 'error' as const, code: 'ERR_NO_VALID_FRAMES', message: 'No frames could be processed' }],
            canRetry: true
          };
        }

        // PRESERVED: Worker readiness and job creation
        const { ensureWorkerReady } = await import('@/server/jobs/render-queue');
        await ensureWorkerReady();
        const supabase = createServiceClient();
        const jobIds: string[] = [];

        for (const partition of scenePartitions) {
          const scene = buildAnimationSceneFromPartition(partition);
          const frameData = partition.sceneNode.data as any;
          
          // PRESERVED: Frame configuration building
          const config = {
            width: Number(frameData.width),
            height: Number(frameData.height),
            backgroundColor: String(frameData.backgroundColor),
            format: (frameData.format === 'jpeg' ? 'jpeg' : 'png') as 'png'|'jpeg',
            quality: Number(frameData.quality ?? 90),
          } as const;

          const payload = { scene, config } as const;
          const { data: jobRow, error: insErr } = await supabase
            .from('render_jobs')
            .insert({ user_id: ctx.user!.id, status: 'queued', payload })
            .select('id')
            .single();
          if (insErr || !jobRow) continue;

          // PRESERVED: Image queue usage
          const { imageQueue } = await import('@/server/jobs/image-queue');
          await imageQueue.enqueueOnly({
            scene,
            config: { ...config },
            userId: ctx.user!.id,
            jobId: jobRow.id as string,
          });

          jobIds.push(jobRow.id as string);
        }

        if (jobIds.length === 0) {
          return {
            success: false,
            errors: [{ type: 'error' as const, code: 'ERR_NO_VALID_FRAMES', message: 'No frames could be processed' }],
            canRetry: true,
          };
        }

        // PRESERVED: Single job inline wait
        if (jobIds.length === 1) {
          const waitResult = await generationService.waitForJobCompletion(jobIds[0]!);
          if (waitResult.completed) {
            return { success: true, imageUrl: waitResult.publicUrl, jobId: jobIds[0]!, totalFrames: 1 };
          }
        }

        return { success: true, jobIds, totalFrames: scenePartitions.length };
        
      } catch (error) {
        return generationService.createErrorResponse(error);
      }
    }),

  // ==================== PRESERVED: INDIVIDUAL GENERATION (PERFORMANCE OPTIMIZED) ====================
  
  generateSceneNode: protectedProcedure
    .input(generateSingleSceneInputSchema)
    .mutation(async ({ input, ctx }) => {
      // PRESERVED: All validation, job limits, performance optimizations via shared service
      return await generationService.generateSingleScene(
        input.nodes,
        input.edges,
        input.targetSceneNodeId,
        ctx
      );
    }),

  generateFrameNode: protectedProcedure
    .input(generateSingleFrameInputSchema)
    .mutation(async ({ input, ctx }) => {
      // PRESERVED: All validation, minimal frame validation, performance optimizations via shared service
      return await generationService.generateSingleFrame(
        input.nodes,
        input.edges,
        input.targetFrameNodeId,
        ctx
      );
    }),

  // ==================== PRESERVED: VALIDATION & UTILITIES ====================
  
  validateScene: protectedProcedure
    .input(validateSceneInputSchema)
    .query(async ({ input }) => {
      // PRESERVED: Complete validation pipeline
      const { backendNodes, backendEdges } = generationService.preprocessInput(input.nodes, input.edges);
      const validation = await generationService.validateComplete(backendNodes, backendEdges, input.nodes, input.edges);
      return validation;
    }),

  // PRESERVED: Debug execution capability
  debugExecution: protectedProcedure
    .input(debugExecutionInputSchema)
    .mutation(async ({ input, ctx }) => {
      try {
        const { backendNodes, backendEdges } = generationService.preprocessInput(input.nodes, input.edges);
        
        // PRESERVED: Debug execution with exact original logic
        const { ExecutionEngine } = await import('@/server/animation-processing/execution-engine');
        const engine = new ExecutionEngine();
        
        const targetIdentifierId = backendNodes.find(n => n.id === input.targetNodeId)?.data?.identifier?.id ?? input.targetNodeId;
        
        const debugContext = await engine.executeFlowDebug(
          backendNodes as any,
          backendEdges,
          targetIdentifierId
        );

        return {
          success: true,
          executionLog: debugContext.executionLog ?? [],
          nodeOutputs: Array.from(debugContext.nodeOutputs.entries()).map(([key, output]) => ({
            nodeId: key.split('.')[0]!,
            portId: key.split('.')[1] ?? 'output',
            type: output.type,
            data: output.data,
          })),
        };
      } catch (error) {
        return generationService.createErrorResponse(error);
      }
    }),

  getNodeDefinition: publicProcedure
    .input(z.object({ nodeType: z.string() }))
    .query(({ input }) => {
      // PRESERVED: Node definition lookup
      const definition = getNodeDefinition(input.nodeType);
      if (!definition) {
        throw new Error(`Unknown node type: ${input.nodeType}`);
      }
      return definition;
    }),

  getDefaultSceneConfig: publicProcedure.query(() => {
    // PRESERVED: Default scene configuration
    return DEFAULT_SCENE_CONFIG;
  }),

  // ==================== PRESERVED: JOB STATUS & MONITORING ====================
  
  getRenderJobStatus: protectedProcedure
    .input(z.object({ jobId: z.string() }))
    .query(async ({ input, ctx }) => {
      // PRESERVED: Job status checking with user ownership validation
      const supabase = createServiceClient();
      const { data: current } = await supabase
        .from('render_jobs')
        .select('id, status, output_url, error')
        .eq('id', input.jobId)
        .eq('user_id', ctx.user.id)
        .single();
      
      const currentData = current as { id: string; status: string; output_url: string | null; error: string | null } | null;

      return { 
        jobId: input.jobId, 
        status: (currentData?.status as 'queued' | 'processing' | 'completed' | 'failed') ?? 'unknown', 
        videoUrl: (currentData?.output_url as string) ?? null, 
        error: (currentData?.error as string) ?? null 
      } as const;
    }),
});

